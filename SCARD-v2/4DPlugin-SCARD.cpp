/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-SCARD.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : SCARD
 #	author : miyako
 #	2020/06/08
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-SCARD.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- SCARD
            
			case 1 :
				SCARD_Get_readers(params);
				break;
			case 2 :
				SCARD_Read_tag(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark libpcsc

LONG getData(SCARDHANDLE hCard,
                     const SCARD_IO_REQUEST *pioSendPci,
                     LPCBYTE pbSendBuffer,
                     DWORD cbSendLength,
                     SCARD_IO_REQUEST *pioRecvPci,
                     LPBYTE pbRecvBuffer,
                     LPDWORD pcbRecvLength,
                     CUTF8String& Param,
                     getDataMode mode) {
    
    C_BLOB temp;
    
    /* default values */
    switch (mode)
    {
        case getDataMode_Type:
        {
            uint8_t cardType = 0L;/* unknown */
            Param = CUTF8String((const uint8_t *)&cardType, 1);
        }
            break;
        default:
            break;
    }
    
    LONG lResult;
    
    lResult = SCardTransmit(hCard,
                                                    pioSendPci,
                                                    pbSendBuffer,
                                                    cbSendLength,
                                                    pioRecvPci,
                                                    pbRecvBuffer,
                                                    pcbRecvLength);
    switch(lResult)
    {
        case SCARD_S_SUCCESS:
        {
            DWORD cbRecvLength = *pcbRecvLength;
            
            BYTE SW1 = pbRecvBuffer[cbRecvLength - 2];
            BYTE SW2 = pbRecvBuffer[cbRecvLength - 1];
            
            if ( SW1 != 0x90 || SW2 != 0x00 )
            {
                if ( SW1 == 0x63 && SW2 == 0x00 )
                {
                    /* data is not available */
                }
            }
            else
            {
                switch (mode)
                {
                    case getDataMode_ID:
                        Param = CUTF8String((const uint8_t *)pbRecvBuffer, cbRecvLength-2);
                        break;
                    case getDataMode_Type:
                    {
                        uint8_t cardType = pbRecvBuffer[0];
                        Param = CUTF8String((const uint8_t *)&cardType, 1);
                    }
                        break;
                    case getDataMode_Sys:
                    {
                        if (cbRecvLength - 2 != 19 || pbRecvBuffer[0] != 0x01)
                        {
                            lResult = SCARD_F_INTERNAL_ERROR;
                        }else
                        {
                            Param = CUTF8String((const uint8_t *)&pbRecvBuffer[cbRecvLength - 4], 2);
                        }
                    }
                        break;
                    case getDataMode_Name:
                    {
#ifdef _WIN32
                        wchar_t    buf[LIBPCSC_MAX_STRING_LENGTH];
                        int len = MultiByteToWideChar(CP_ACP, 0, (LPCCH)pbRecvBuffer, cbRecvLength - 2, (LPWSTR)buf, LIBPCSC_MAX_STRING_LENGTH);
                        if(len)
                        {
                            C_TEXT t;
                            t.setUTF16String((const PA_Unichar*)buf, len);
                            t.copyUTF8String(&Param);
                        }
#endif
                    }
                    default:
                        break;
                }
            }
        }
            break;
        case 0x458:
            lResult = SCARD_W_REMOVED_CARD;
            break;
        case 0x16:
            lResult = SCARD_E_INVALID_PARAMETER;
            break;
        default:
            
            break;
    }
    
    return lResult;
}

#pragma mark libusb (mac)

static void print_hex(const uint8_t *pbtData, const size_t szBytes, std::string &hex) {
    
    std::vector<uint8_t> buf((szBytes * 2) + 1);
    memset((char *)&buf[0], 0, buf.size());
    
    for (size_t i = 0; i < szBytes; ++i) {
        sprintf((char *)&buf[i * 2], "%02x", pbtData[i]);
    }
    
    hex = std::string((char *)&buf[0], (szBytes * 2));
}
     
#if VERSIONMAC

struct device_info {
  libusb_device *dev;
  libusb_device_handle *dh;
  uint8_t ep_in;
  uint8_t ep_out;
  int interface_num;
};

typedef device_info usb_device_info;

static bool get_usb_information(libusb_device_handle *dh, usb_device_info *devinfo) {
    
    memset(devinfo, 0, sizeof(usb_device_info));
    
    libusb_device *dev;
    struct libusb_config_descriptor *conf;
    const struct libusb_endpoint_descriptor *endp;
    const struct libusb_interface *intf;
    const struct libusb_interface_descriptor *intdesc;
    
    dev = libusb_get_device(dh);
    
    if(dev == NULL){
        std::cout << "device get error..." << std::endl;
        return false;
    }
    
    devinfo->dh = dh;
    devinfo->dev = dev;
    
    libusb_get_config_descriptor(dev, 0, &conf);
    
    for(int i = 0; i < (int)conf->bNumInterfaces; i++){
        intf = &conf->interface[i];
        for(int j = 0; j < intf->num_altsetting; j++){
            intdesc = &intf->altsetting[j];
            for(int k = 0; k < (int)intdesc->bNumEndpoints; k++){
                endp = &intdesc->endpoint[k];
                
                switch(endp->bmAttributes & LIBUSB_TRANSFER_TYPE_MASK) {
                    case LIBUSB_TRANSFER_TYPE_BULK:
                        //printf("bulk endpoint: %02x\n", endp->bEndpointAddress);
                        if((endp->bEndpointAddress & 0x80) == LIBUSB_ENDPOINT_IN){
                            devinfo->ep_in = endp->bEndpointAddress;
                        }
                        if((endp->bEndpointAddress & 0x80) == LIBUSB_ENDPOINT_OUT){
                            devinfo->ep_out = endp->bEndpointAddress;
                        }
                        break;
                    case LIBUSB_TRANSFER_TYPE_INTERRUPT:
                        //printf("interrupt endpoint: %02x\n", endp->bEndpointAddress);
                        break;
                }
            }
        }
    }
    libusb_free_config_descriptor(conf);
    
    return true;
}

static short checksum(char cmd, uint8_t *buf, int size) {
    
  int sum = (unsigned int)cmd;
  for(int i = 0; i < size; i++){
    sum += buf[i];
  }
  return (0x100 - sum) % 0x100;
}

static int packet_init(usb_device_info *devinfo, int timeout) {
    
  uint8_t cmd[6];
  int ret;
  int len;

  // ack command
  memcpy(cmd, "\x00\x00\xff\x00\xff\x00", 6);
      
  ret = libusb_bulk_transfer(devinfo->dh, devinfo->ep_out,
                 (unsigned char *)cmd, sizeof(cmd), &len, timeout);
    
  if(ret < 0) std::cout << "data send error..." << std::endl;
    
  return ret;
}

static size_t packet_send(usb_device_info *devinfo, uint8_t *buf, int size,
                          std::vector<uint8_t> *usbbuf, int timeout) {
    
    uint8_t rcv[LIBUSB_DATASIZE], rbuf[LIBUSB_DATASIZE];
    
    int len;
    int ret;
    
    ret = libusb_bulk_transfer(devinfo->dh, devinfo->ep_out,
                               (unsigned char *)buf, size, &len, timeout);
    if(ret < 0){
        std::cout << "data send error..." << std::endl;
        return 0;
    }
    
    // receive ack/nck
    ret = libusb_bulk_transfer(devinfo->dh, devinfo->ep_in,
                               (unsigned char *)rcv, sizeof(rcv), &len, timeout);
    if(ret < 0){
        std::cout << "data receive error..." << std::endl;
        return 0;
    }
    //printf("recv <- ");
    //show_data(rcv, len);
    
    // receive response
    ret = libusb_bulk_transfer(devinfo->dh, devinfo->ep_in,
                               (unsigned char *)rbuf, sizeof(rbuf), &len, timeout);
    if(ret < 0){
        std::cout << "data receive error..." << std::endl;
        return 0;
    }
    
    if(len > usbbuf->size()) {
        usbbuf->resize(len);
    }
    
    memcpy(&usbbuf->at(0), rbuf, len);

    return len;
}

/*
 Sony„ÅÆPaSoRi RC-S380
 https://github.com/nfcpy/nfcpy/tree/master/src/nfc/clf
 https://qiita.com/saturday06/items/333fcdf5b3b8030c9b05
 
 */

static size_t packet_write(usb_device_info *devinfo, uint8_t *buf, int size,
                             std::vector<uint8_t> *usbbuf, int timeout) {
    
  uint8_t cmd[LIBUSB_DATASIZE];
  int n;
  short csum;

  n = size;
  if(n < 1) return 0;

  // data = 0xd6 + data
  // len = len(data)
  // 00 00 ff ff ff len(L) len(H) checksum(len) data checksum(data) 00
  cmd[0] = 0x00; cmd[1] = 0x00; cmd[2] = 0xff;
  cmd[3] = 0xff; cmd[4] = 0xff;
  cmd[5] = ((n + 1) & 0xff) ; cmd[6] = ((n + 1) & 0xff00) >> 8;
  csum = (0x100 - (cmd[5] + cmd[6])) % 0x100;
  cmd[7] = csum;

  cmd[8] = 0xd6;
  memcpy(cmd + 9, buf, size);

  csum = checksum(cmd[8], buf, size);
  cmd[9 + n] = csum;
  
  cmd[10 + n] = 0x00;
  n += 11;
  
  return packet_send(devinfo, cmd, n, usbbuf, timeout);
}

static size_t packet_setcommandtype(usb_device_info *devinfo,
                                      std::vector<uint8_t> *usbbuf, int timeout) {
    
  uint8_t cmd[2];
  memcpy(cmd, "\x2a\x01", 2);
  return packet_write(devinfo, cmd, sizeof(cmd), usbbuf, timeout);
}

static size_t packet_inset_rf(usb_device_info *devinfo, char type,
                                std::vector<uint8_t> *usbbuf, int timeout) {
    
  uint8_t cmd[5];
    
  if(type == 'F') memcpy(cmd, "\x00\x01\x01\x0f\x01", 5); // 212F
  if(type == 'A') memcpy(cmd, "\x00\x02\x03\x0f\x03", 5); // 106A
  if(type == 'B') memcpy(cmd, "\x00\x03\x07\x0f\x07", 5); // 106B
    
  return packet_write(devinfo, cmd, sizeof(cmd), usbbuf, timeout);
}

static size_t packet_inset_protocol_1(usb_device_info *devinfo,
                                        std::vector<uint8_t> *usbbuf, int timeout) {
    
  uint8_t cmd[39];
    
  memcpy(cmd, "\x02\x00\x18\x01\x01\x02\x01\x03\x00\x04\x00\x05\x00\x06\x00\x07\x08\x08\x00\x09\x00\x0a\x00\x0b\x00\x0c\x00\x0e\x04\x0f\x00\x10\x00\x11\x00\x12\x00\x13\x06", 39);
    
  return packet_write(devinfo, cmd, sizeof(cmd), usbbuf, timeout);
}

static size_t packet_inset_protocol_2(usb_device_info *devinfo, char type,
                                      std::vector<uint8_t> *usbbuf, int timeout) {
    
  uint8_t cmd[11];
    
  int len;
  if(type == 'F'){
    len = 3;
    memcpy(cmd, "\x02\x00\x18", len);
  }
  if(type == 'A'){
    len = 11;
    memcpy(cmd, "\x02\x00\x06\x01\x00\x02\x00\x05\x01\x07\x07", len);
  }
  if(type == 'B'){
    len = 11;
    memcpy(cmd, "\x02\x00\x14\x09\x01\x0a\x01\x0b\x01\x0c\x01", len);
  }
    
  return packet_write(devinfo, cmd, len, usbbuf, timeout);
}

static size_t packet_sens_req(usb_device_info *devinfo, char type,
                                std::vector<uint8_t> *usbbuf, int timeout) {
    
  uint8_t cmd[9];
  int len;
  if(type == 'F'){
    len = 9;
    memcpy(cmd, "\x04\x6e\x00\x06\x00\xff\xff\x01\x00", len);
  }
  if(type == 'A'){
    len = 4;
    memcpy(cmd, "\x04\x6e\x00\x26", len);/* TODO: send 7-bits */
  }
  if(type == 'B'){
    len = 6;
    memcpy(cmd, "\x04\x6e\x00\x05\x00\x10", len);
  }
  return packet_write(devinfo, cmd, len, usbbuf, timeout);
}

static size_t packet_switch_rf(usb_device_info *devinfo,
                                 std::vector<uint8_t> *usbbuf, int timeout) {
    
  uint8_t cmd[2];
  memcpy(cmd, "\x06\x00", 2);
    
  return packet_write(devinfo, cmd, sizeof(cmd), usbbuf, timeout);
}

#endif

#pragma mark -

void SCARD_Get_readers(PA_PluginParameters params) {

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_CollectionRef returnValues = PA_CreateCollection();
    
    DWORD msWaitForSingleObject = DEFAULT_TIMEOUT_MS_FOR_RESOURCE_MANAGER;
    
    uint32_t scope = SCARD_SCOPE_USER;
    
    bool use_libusb = false;
    bool use_libnfc = false;
    
    if(options) {
        
        if(ob_is_defined(options, L"libusb")) {
            use_libusb = ob_get_b(options, L"libusb");
        }
        
        if(ob_is_defined(options, L"libnfc")) {
            use_libnfc = ob_get_b(options, L"libnfc");
        }
        
        if(ob_is_defined(options, L"scope")) {
            int _scope = ob_get_n(options, L"scope");
            switch (_scope) {
                case SCARD_SCOPE_USER:
                case SCARD_SCOPE_TERMINAL:
                case SCARD_SCOPE_SYSTEM:
                    scope = _scope;
                    break;
                default:
                    break;
            }
        }
        
        CUTF8String _groups;
        if(ob_is_defined(options, L"groups")) {
            if (ob_get_s(options, L"groups", &_groups)) {
            
                if (_groups == (const uint8_t *)"all") {
                    
                }
                
                if (_groups == (const uint8_t *)"default") {
                    
                }
            }
        }
        
        if(ob_is_defined(options, L"timeout")) {
            int _timeout = ob_get_n(options, L"timeout");
            if(_timeout > 0) {
                msWaitForSingleObject = _timeout;
            }
        }
    }
        
    SCARDCONTEXT hContext;
    
    LONG lResult = SCardEstablishContext(scope, NULL, NULL, &hContext);
    
    #if VERSIONWIN
        /* http://eternalwindows.jp/security/scard/scard02.html */
        if(lResult == SCARD_E_NO_SERVICE) {
            HANDLE hEvent = SCardAccessStartedEvent();
            DWORD dwResult = WaitForSingleObject(hEvent, msWaitForSingleObject);
            if (dwResult == WAIT_OBJECT_0) {
                lResult = SCardEstablishContext(scope, NULL, NULL, &hContext);
            }
            SCardReleaseStartedEvent();
        }
    #endif
    
    if (lResult == SCARD_S_SUCCESS) {
        
        DWORD len;
        lResult = SCardListReaders(hContext, SCARD_ALL_READERS, NULL, &len);
        if (lResult == SCARD_S_SUCCESS) {
         
            std::vector<TCHAR>buf(len);
            lResult = SCardListReaders(hContext, SCARD_ALL_READERS, &buf[0], &len);
            if (lResult == SCARD_S_SUCCESS) {
             
                LPTSTR pReader = (LPTSTR)&buf[0];
                if(pReader) {
                    while ('\0' != *pReader) {
                        
                        PA_ObjectRef reader = PA_CreateObject();
#if VERSIONWIN
                        ob_set_a(reader, L"name", pReader);
                        pReader = pReader + wcslen(pReader) + 1;
#else
                        ob_set_s(reader, L"name", pReader);
                        pReader = pReader + strlen(pReader) + 1;
#endif

                        PA_Variable v = PA_CreateVariable(eVK_Object);
                        PA_SetObjectVariable(&v, reader);
                        PA_SetCollectionElement(returnValues, PA_GetCollectionLength(returnValues), v);
                        PA_ClearVariable(&v);
                    }

                }
                
            }
        }
        SCardReleaseContext(hContext);
    }
    
#if VERSIONMAC
        
    if(use_libusb) {
        
        int libusb_result = libusb_init(NULL);
        
        if(libusb_result >= 0) {

            libusb_device **devs;
            ssize_t count = libusb_get_device_list(NULL, &devs);
            
            if(count >0) {
             
                for(int i = 0; i < count; i++){
                    libusb_device *dev = devs[i];
                    libusb_device_descriptor desc;
                    libusb_result = libusb_get_device_descriptor(dev, &desc);
                    if(libusb_result >= 0) {
                        
                        PA_ObjectRef reader = PA_CreateObject();
                        
                        std::vector<uint8_t> buf(5);
                        
                        memset((char *)&buf[0], 0, buf.size());
                        sprintf((char *)&buf[0], "%04x", desc.idVendor);
                        std::string idVendor = std::string((char *)&buf[0], 4);
                        memset((char *)&buf[0], 0, buf.size());
                        sprintf((char *)&buf[0], "%04x", desc.idProduct);
                        std::string idProduct = std::string((char *)&buf[0], 4);
                        
                        PA_ObjectRef usb = PA_CreateObject();
                        
                        ob_set_s(usb, L"vid", idVendor.c_str());
                        ob_set_s(usb, L"pid", idProduct.c_str());
                        
//                        ob_set_n(usb, L"busNumber", libusb_get_bus_number(dev));
//                        ob_set_n(usb, L"deviceAddress", libusb_get_device_address(dev));
                        
                        ob_set_o(reader, L"usb", usb);
                        
                        libusb_device_handle *dh;
                        if(0 == libusb_open(dev, &dh)) {
                            
                            buf.resize(LIBUSB_MAX_STRING_LENGTH);
                            memset((char *)&buf[0], 0, buf.size());
                            
                            libusb_result = libusb_get_string_descriptor_ascii(dh,
                                                                               desc.iManufacturer,
                                                                               (unsigned char *)&buf[0], (int)buf.size());
                            
                            if(libusb_result > 0) {
                                std::string iManufacturer = std::string((char *)&buf[0], libusb_result);
                                ob_set_s(reader, L"manufacturer", iManufacturer.c_str());
                            }
                            memset((char *)&buf[0], 0, buf.size());
                            
                            libusb_result = libusb_get_string_descriptor_ascii(dh,
                                                                               desc.iProduct,
                                                                               (unsigned char *)&buf[0], (int)buf.size());
                            
                            if(libusb_result > 0) {
                                std::string iProduct = std::string((char *)&buf[0], libusb_result);
                                ob_set_s(reader, L"product", iProduct.c_str());
                            }
                            memset((char *)&buf[0], 0, buf.size());
                            
                            libusb_result = libusb_get_string_descriptor_ascii(dh,
                                                                               desc.iSerialNumber,
                                                                               (unsigned char *)&buf[0], (int)buf.size());
                            
                            if(libusb_result > 0) {
                                std::string iSerialNumber = std::string((char *)&buf[0], libusb_result);
                                ob_set_s(reader, L"serial", iSerialNumber.c_str());
                            }

                            libusb_release_interface(dh, 0);
                            libusb_close(dh);
                        }
                        
                        PA_Variable v = PA_CreateVariable(eVK_Object);
                        PA_SetObjectVariable(&v, reader);
                        PA_SetCollectionElement(returnValues, PA_GetCollectionLength(returnValues), v);
                        PA_ClearVariable(&v);
                    }
                    
                }
                libusb_free_device_list(devs, 1);
            }
            libusb_exit(NULL);
        }
           
    }
        
    if(use_libnfc) {
        
        nfc_context *context;
        nfc_init(&context);
        if (context) {
            
            nfc_connstring connstrings[LIBNFC_MAX_DEVICE_COUNT];
            
            size_t szFound = nfc_list_devices(context, connstrings, LIBNFC_MAX_DEVICE_COUNT);
            
            for(int i = 0; i < szFound; i++){
                
                PA_ObjectRef reader = PA_CreateObject();
                
                char *connstring = connstrings[i];
                
                std::string nfcid = std::string(connstring, strlen(connstring));
                ob_set_s(reader, L"nfc", nfcid.c_str());
                
                nfc_device *device = nfc_open(context, connstring);
                if(device) {
                    
                    /* this information is not reliable
                     ob_set_s(reader, L"name", nfc_device_get_name(device));
                     */

                    char *_info = NULL;
                    if(!nfc_device_get_information_about(device, &_info)) {
                        /* return value (len) is not reliable */
                        std::string info = std::string(_info, strlen(_info));
                        ob_set_s(reader, L"info", info.c_str());

                        nfc_free(_info);
                    }
 
                    nfc_close(device);
                }
                
                PA_Variable v = PA_CreateVariable(eVK_Object);
                PA_SetObjectVariable(&v, reader);
                PA_SetCollectionElement(returnValues, PA_GetCollectionLength(returnValues), v);
                PA_ClearVariable(&v);
                
            }

            nfc_exit(context);
        }
    }

#endif
    
    PA_ReturnCollection(params, returnValues);
}

void SCARD_Read_tag(PA_PluginParameters params) {
    
    PA_ObjectRef returnValue = PA_CreateObject();
    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    ob_set_b(returnValue, L"success", false);
    
    int timeout = 3; //seconds
    
    bool use_libpcsc = false;
    bool use_libusb = false;
    bool use_libnfc = false;
    
    /* libusb */
#if VERSIONMAC
	CUTF8String vid;
	CUTF8String pid;
	char nfc_type = 'F';
	int libusb_timeout = LIBUSB_API_TIMEOUT;
	int libusb_timeout_for_polling = LIBUSB_API_TIMEOUT_FOR_POLLING;
#endif

    /* libnfc */
#if VERSIONMAC
	int libnfc_timeout = LIBNFC_API_TIMEOUT;
	CUTF8String connstring;
	nfc_modulation modulation;
	modulation.nmt = NMT_FELICA;
	modulation.nbr = NBR_212;
#endif

            
    /* libscpc */
    #if VERSIONWIN
    LPTSTR lpszReaderName = NULL;
    CUTF16String name;
    #else
    LPSTR lpszReaderName = NULL;
    CUTF8String name;
    #endif
    DWORD protocols = SCARD_PROTOCOL_T0|SCARD_PROTOCOL_T1;
    DWORD mode = SCARD_SHARE_SHARED;
    DWORD scope = SCARD_SCOPE_USER;
    
    if(options) {
        
        if(ob_is_defined(options, L"protocol")) {
            int _protocol = ob_get_n(options, L"protocol");
            if(_protocol >= 0) {
                protocols = _protocol;
            }
        }
        
        if(ob_is_defined(options, L"mode")) {
            int _mode = ob_get_n(options, L"mode");
            if(_mode >= 0) {
                mode = _mode;
            }
        }
        
        if(ob_is_defined(options, L"scope")) {
            int _scope = ob_get_n(options, L"scope");
            if(_scope >= 0) {
                scope = _scope;
            }
        }
        
        if(ob_is_defined(options, L"name")) {
#if VERSIONWIN
            ob_get_a(options, L"name", &name);
            lpszReaderName = (LPTSTR)name.c_str();
#else
            
            ob_get_s(options, L"name", &name);
            lpszReaderName = (LPSTR)name.c_str();
#endif
            if(name.length()) {
                use_libpcsc = true;
            }
        }
#if VERSIONMAC
        if(ob_is_defined(options, L"usb")) {
            PA_ObjectRef usb = ob_get_o(options, L"usb");
            if(usb) {
                if(ob_is_defined(usb, L"vid")) {
                    if(ob_get_s(usb, L"vid", &vid)) {
                        if(vid.length()) {
                            if(ob_is_defined(usb, L"pid")) {
                                if(ob_get_s(usb, L"pid", &pid)) {
                                    if(pid.length()) {
                                        use_libusb = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        if(use_libusb) {
            CUTF8String _card;
            if(ob_get_s(options, L"card", &_card)) {
                if(_card == (const uint8_t *)"FeliCa") {
                    nfc_type = 'F';
                    /*
                     Suica
                     WAON
                     */
                }
                if(_card == (const uint8_t *)"TypeB") {
                    nfc_type = 'B';
                    /*
                     VISA payWave
                     PayPass (MasterCard)
                     jyumin-kihon-daicho (Japan
                     Passport (Japan)
                     */
                }
                if(_card == (const uint8_t *)"TypeA") {
                    nfc_type = 'A';
                    /*
                     VISA payWave
                     PayPass (MasterCard)
                     jyumin-kihon-daicho (Japan
                     Passport (Japan)
                     */
                }
            }
        }else{
            if(ob_is_defined(options, L"nfc")) {
                if(ob_get_s(options, L"nfc", &connstring)) {
                    if(connstring.length()) {
                        use_libnfc = true;
                    }
                }
            }
        }
#endif

        if(ob_is_defined(options, L"timeout")) {
            int _timeout = ob_get_n(options, L"timeout");
            if(_timeout > 0) {
                timeout = _timeout;
            }
        }

#if VERSIONMAC     
        if(use_libnfc) {
            if(ob_is_defined(options, L"card")) {
                CUTF8String _card;
                if(ob_get_s(options, L"card", &_card)) {
                    if(_card == (const uint8_t *)"FeliCa") {
                        modulation.nmt = NMT_FELICA;
                        modulation.nbr = NBR_424;
                    }
                    if(_card == (const uint8_t *)"TypeA") {
                        modulation.nmt = NMT_ISO14443A;
                        modulation.nbr = NBR_106;
                    }
                    if(_card == (const uint8_t *)"TypeB") {
                        modulation.nmt = NMT_ISO14443B;
                        modulation.nbr = NBR_106;
                    }
                }
            }
        }
#endif        
        
    }
        
    if(use_libpcsc) {
        
        SCARDCONTEXT hContext;
        
        LONG lResult = SCardEstablishContext(scope, NULL, NULL, &hContext);
        
        #if VERSIONWIN
            /* http://eternalwindows.jp/security/scard/scard02.html */
            if(lResult == SCARD_E_NO_SERVICE) {
                HANDLE hEvent = SCardAccessStartedEvent();
                DWORD dwResult = WaitForSingleObject(hEvent, DEFAULT_TIMEOUT_MS_FOR_RESOURCE_MANAGER);
                if (dwResult == WAIT_OBJECT_0) {
                    lResult = SCardEstablishContext(scope, NULL, NULL, &hContext);
                }
                SCardReleaseStartedEvent();
            }
        #endif
        
        if (lResult == SCARD_S_SUCCESS) {
            
            SCARD_READERSTATE readerState;
            readerState.szReader = lpszReaderName;
            readerState.dwCurrentState = SCARD_STATE_UNAWARE;

            
            /* return immediately; check state */
            lResult = SCardGetStatusChange(hContext, 0, &readerState, 1);
            if (lResult == SCARD_S_SUCCESS) {
            
                int is_card_present = 0;
                
                time_t startTime = time(0);
                time_t anchorTime = startTime;
                
                bool isPolling = true;

                while (isPolling) {
                    
                    time_t now = time(0);
                    time_t elapsedTime = abs(startTime - now);
                    
                    if(elapsedTime > 0)
                    {
                        startTime = now;
                        PA_YieldAbsolute();
                    }
                    
                    elapsedTime = abs(anchorTime - now);
                    
                    if(elapsedTime < timeout) {

                        if (readerState.dwEventState & SCARD_STATE_EMPTY) {
                            lResult = SCardGetStatusChange(hContext, LIBPCSC_API_TIMEOUT, &readerState, 1);
                        }
                        
                        if (readerState.dwEventState & SCARD_STATE_UNAVAILABLE) {
                            isPolling = false;
                        }
                        
                        if (readerState.dwEventState & SCARD_STATE_PRESENT) {
                            is_card_present = 1;
                            isPolling = false;
                        }
                         
                    }else{
                        /* timeout */
                        isPolling = false;
                    }
                       
                }
                
                if(is_card_present) {
             
                    SCARDHANDLE hCard;
                    DWORD dwActiveProtocol;
                    DWORD dwProtocol;
                    DWORD dwAtrSize;
                    DWORD dwState;
                    
                    BYTE atr[256];

                    C_BLOB temp;
                    
                    lResult = SCardConnect(hContext,
                                                                 lpszReaderName,
                                                                 mode,
                                                                 protocols,
                                                                 &hCard,
                                                                 &dwActiveProtocol);
                    switch (lResult)
                    {
                        case (LONG)SCARD_W_REMOVED_CARD:
                            /* SCARD_W_REMOVED_CARD */
                            break;
                        case SCARD_S_SUCCESS:
                            lResult = SCardStatus(hCard, NULL, NULL, &dwState, &dwProtocol, atr, &dwAtrSize);
                            if (lResult == SCARD_S_SUCCESS) {
                                
                                BYTE pbSendBuffer_GetIDm[5] = {
                                    APDU_CLA_GENERIC,
                                    APDU_INS_GET_DATA,
                                    APDU_P1_GET_UID,
                                    APDU_P2_NONE,
                                    APDU_LE_MAX_LENGTH
                                };
                                
                                BYTE pbSendBuffer_GetPMm[5] = {
                                    APDU_CLA_GENERIC,
                                    APDU_INS_GET_DATA,
                                    APDU_P1_GET_PMm,
                                    APDU_P2_NONE,
                                    APDU_LE_MAX_LENGTH
                                };

                                BYTE pbSendBuffer_GetCID[5] = {
                                    APDU_CLA_GENERIC,
                                    APDU_INS_GET_DATA,
                                    APDU_P1_GET_CARD_ID,
                                    APDU_P2_NONE,
                                    APDU_LE_MAX_LENGTH
                                };

                                BYTE pbSendBuffer_GetName[5] = {
                                    APDU_CLA_GENERIC,
                                    APDU_INS_GET_DATA,
                                    APDU_P1_GET_CARD_NAME,
                                    APDU_P2_NONE,
                                    APDU_LE_MAX_LENGTH
                                };
                                
                                BYTE pbSendBuffer_GetType[5] = {
                                    APDU_CLA_GENERIC,
                                    APDU_INS_GET_DATA,
                                    APDU_P1_GET_CARD_TYPE,
                                    APDU_P2_NONE,
                                    APDU_LE_MAX_LENGTH
                                };

                                BYTE pbSendBuffer_GetTypeName[5] = {
                                    APDU_CLA_GENERIC,
                                    APDU_INS_GET_DATA,
                                    APDU_P1_GET_CARD_TYPE_NAME,
                                    APDU_P2_NONE,
                                    APDU_LE_MAX_LENGTH
                                };
                                
                                BYTE pbRecvBuffer[256];
                                DWORD pcbRecvLength = 256;

                                /*
                                lResult = getData(hCard,
                                    SCARD_PCI_T1,
                                    pbSendBuffer_GetSys,
                                    sizeof(pbSendBuffer_GetSys),
                                    NULL,
                                    pbRecvBuffer,
                                    &pcbRecvLength,
                                    Param_SystemCode,
                                    getDataMode_Sys);
                                    */

                                CUTF8String idm;
                                
                                lResult = getData(hCard,
                                                  SCARD_PCI_T1,
                                                  pbSendBuffer_GetIDm,
                                                  sizeof(pbSendBuffer_GetIDm),
                                                  NULL,
                                                  pbRecvBuffer,
                                                  &pcbRecvLength,
                                                  idm,
                                                  getDataMode_ID);
                                
                                if(lResult == SCARD_S_SUCCESS) {
                                    std::string _IDm;
                                    print_hex(idm.c_str(), 8, _IDm);
                                    ob_set_s(returnValue, L"IDm", _IDm.c_str());
                                    ob_set_b(returnValue, L"success", true);
                                }
                                
                                CUTF8String pmm;
                                
                                lResult = getData(hCard,
                                                  SCARD_PCI_T1,
                                                  pbSendBuffer_GetPMm,
                                                  sizeof(pbSendBuffer_GetPMm),
                                                  NULL,
                                                  pbRecvBuffer,
                                                  &pcbRecvLength,
                                                  pmm,
                                                  getDataMode_ID);

                                if(lResult == SCARD_S_SUCCESS) {
                                    std::string _PMm;
                                    print_hex(pmm.c_str(), 8, _PMm);
                                    ob_set_s(returnValue, L"PMm", _PMm.c_str());
                                }
                                
                                CUTF8String typ;
                                
                                lResult = getData(hCard,
                                                  SCARD_PCI_T1,
                                                  pbSendBuffer_GetType,
                                                  sizeof(pbSendBuffer_GetType),
                                                  NULL,
                                                  pbRecvBuffer,
                                                  &pcbRecvLength,
                                                  typ,
                                                  getDataMode_Type);
                                
                                if(lResult == SCARD_S_SUCCESS) {
									std::string _typ;
									print_hex(typ.c_str(), 1, _typ);
                                    ob_set_s(returnValue, L"type", (const char *)_typ.c_str());
                                }
                                
                                CUTF8String cid;
                                
                                lResult = getData(hCard,
                                                  SCARD_PCI_T1,
                                                  pbSendBuffer_GetCID,
                                                  sizeof(pbSendBuffer_GetCID),
                                                  NULL,
                                                  pbRecvBuffer,
                                                  &pcbRecvLength,
                                                  cid,
                                                  getDataMode_Type);
                                
                                if(lResult == SCARD_S_SUCCESS) {
									std::string _cid;
									print_hex(cid.c_str(), 1, _cid);
                                    ob_set_s(returnValue, L"cid", (const char *)_cid.c_str());
                                }
                                
                                CUTF8String cname;
                                
                                lResult = getData(hCard,
                                                  SCARD_PCI_T1,
                                                  pbSendBuffer_GetName,
                                                  sizeof(pbSendBuffer_GetName),
                                                  NULL,
                                                  pbRecvBuffer,
                                                  &pcbRecvLength,
                                                  cname,
                                                  getDataMode_Name);
                                
                                if(lResult == SCARD_S_SUCCESS) {
                                    ob_set_s(returnValue, L"name", (const char *)cname.c_str());
                                }
                                
                                CUTF8String tname;
                                
                                lResult = getData(hCard,
                                                  SCARD_PCI_T1,
                                                  pbSendBuffer_GetTypeName,
                                                  sizeof(pbSendBuffer_GetTypeName),
                                                  NULL,
                                                  pbRecvBuffer,
                                                  &pcbRecvLength,
                                                  tname,
                                                  getDataMode_Name);
                                
                                if(lResult == SCARD_S_SUCCESS) {
                                    ob_set_s(returnValue, L"typeName", (const char *)tname.c_str());
                                }

                            }/* SCardStatus */
                            SCardDisconnect(hCard, SCARD_LEAVE_CARD);
                            break;
                        default:
                            break;
                    }
 
                }
                
            }
            SCardReleaseContext(hContext);
        }
        
    }

#if VERSIONMAC
    
    if(use_libusb) {
     
        std::vector<uint8_t>usbbuf(LIBUSB_DATASIZE);
        
        int libusb_result = libusb_init(NULL);
        
        if(libusb_result >= 0) {
            
            char *end;
            
            int _vid = (int)strtol((const char *)vid.c_str(),  &end, 16);
            int _pid = (int)strtol((const char *)pid.c_str(),  &end, 16);
            
            bool is_Sony_RC_S380 = ((_vid == 0x054C) && (_pid == 0x06C3));
            bool is_Sony_RC_S360 = ((_vid == 0x054C) && (_pid == 0x02E1));
            
            /*
             Sony NFC Port-100 chipset.
             The only product known to use this chipset is the PaSoRi RC-S380.
             https://github.com/nfcpy/nfcpy/blob/master/src/nfc/clf/rcs380.py
             */
            
            /*
             Sony RC-S956 chipset.
             Products known to use this chipset are the PaSoRi RC-S330, RC-S360, and RC-S370.
             https://github.com/nfcpy/nfcpy/blob/master/src/nfc/clf/rcs956.py
             */
            
            if(is_Sony_RC_S360) {
                
            }
            
            if(is_Sony_RC_S380) {

                 libusb_device_handle *device = libusb_open_device_with_vid_pid(NULL, _vid, _pid);
                 
                 if(device) {
                     
                     /* https://github.com/ysomei/test_getnfcid/blob/master/getdeviceid.cpp */
                     
                     // usb interface setting
                     libusb_set_auto_detach_kernel_driver(device, 1);
                     libusb_set_configuration(device, 1);
                     libusb_claim_interface(device, 0);
                     libusb_set_interface_alt_setting(device, 0, 0);
                     
                     // get usb information
                     
                     usb_device_info devinfo;
                     usb_device_info *devinfop = &devinfo;
                     std::vector<uint8_t> *usbbufp = &usbbuf;
                     
                     if(get_usb_information(device, devinfop)) {
                         
                         packet_init(devinfop, libusb_timeout);
                         
                         packet_setcommandtype(devinfop, usbbufp, libusb_timeout);
                         packet_switch_rf(devinfop, usbbufp, libusb_timeout);
                         
                         packet_inset_rf(devinfop, nfc_type, usbbufp, libusb_timeout);
                         packet_inset_protocol_1(devinfop, usbbufp, libusb_timeout);
                         packet_inset_protocol_2(devinfop, nfc_type,  usbbufp, libusb_timeout);
                          
                         time_t startTime = time(0);
                         time_t anchorTime = startTime;
                         
                         bool isPolling = true;

                         while (isPolling) {
                         
                             time_t now = time(0);
                             time_t elapsedTime = abs(startTime - now);
                             
                             if(elapsedTime > 0)
                             {
                                 startTime = now;
                                 PA_YieldAbsolute();
                             }
                             
                             elapsedTime = abs(anchorTime - now);
                             
                             if(elapsedTime < timeout) {
                                 
                                 size_t len = packet_sens_req(devinfop, nfc_type, usbbufp, libusb_timeout_for_polling);
                                                           
                                 if(len >= 0) {

                                     if(usbbuf[9] == 0x05 && usbbuf[10] == 0x00) {
                                         
                                         int rlen = ((usbbuf[6] << 8) + usbbuf[5]);
                                         
                                         if(rlen == 27) {
                                             
                                             if(usbbuf[6 + 9] == 0x14 && usbbuf[7 + 9] == 0x01) {
                                                 
                                                 uint8_t idm[8], pmm[8];
                                                 
                                                 memcpy(idm, &usbbuf[ 8 + 9], 8);
                                                 memcpy(pmm, &usbbuf[16 + 9], 8);
                                                 
                                                 std::string _IDm;
                                                 print_hex(idm, 8, _IDm);
                                                 ob_set_s(returnValue, L"IDm", _IDm.c_str());
                                                 
                                                 std::string _PMm;
                                                 print_hex(pmm, 8, _PMm);
                                                 ob_set_s(returnValue, L"PMm", _PMm.c_str());
                                                 
                                                 ob_set_b(returnValue, L"success", true);
                                                 
                                                 isPolling = false;
                                             }
                                             
                                         }
                                         
                                         if(isPolling) {
                                             
                                             /* ATQB (response to REQB ) */
                                             if(usbbuf[6 + 9] == 0x50) /* response code */ {
                                                 
                                                 uint8_t nfcid[4], appdata[4], pinfo[3], cid[1];
                                                 
                                                 memcpy(  nfcid, &usbbuf[ 7 + 9], 4);/* PUPI */
                                                 memcpy(appdata, &usbbuf[11 + 9], 4);/* Application Data */
                                                 memcpy(  pinfo, &usbbuf[15 + 9], 3);/* Protocol Info */
                                                 memcpy(    cid, &usbbuf[18 + 9], 1);/* CID */
                                                 
                                                 std::string _nfcid;
                                                 print_hex(nfcid, 4, _nfcid);
                                                 ob_set_s(returnValue, L"pupi", _nfcid.c_str());
                                                 
                                                 std::string _appdata;
                                                 print_hex(appdata, 4, _appdata);
                                                 ob_set_s(returnValue, L"appdata", _appdata.c_str());
                                                 
                                                 std::string _pinfo;
                                                 print_hex(pinfo, 3, _pinfo);
                                                 ob_set_s(returnValue, L"pinfo", _pinfo.c_str());
                                                 
                                                 /*
                                                  std::string _cid;
                                                  print_hex(cid, 1, _cid);
                                                  ob_set_s(returnValue, L"cid", _cid.c_str());
                                                  */
                                                 
                                                 ob_set_b(returnValue, L"success", true);
                                                 
                                                 isPolling = false;
                                                 
                                             }
                                         }
                                         
                                         if(isPolling) {
                                                /* ATQA incomplete: need to implement SAK anti-collision sequence
                                                 http://www.ti.com/lit/an/sloa136/sloa136.pdf
                                                 https://www.nxp.com/docs/en/application-note/AN10833.pdf
                                                 https://github.com/nfc-tools/libnfc/blob/master/examples/nfc-anticol.c
                                                 */
                                         }
                                     }
                                 }else{
                                     /* read/write error */
                                     usleep(LIBUSB_USLEEP_DURATION);
                                 }
                                 
                             }else{
                                 /* timeout */
                                 isPolling = false;
                             }

                         }
                         
                     }
                     
                     // close
                     libusb_release_interface(device, 0);
                     libusb_close(device);
                     
                 }

            }

            libusb_exit(NULL);
        }
        
    }
    
    if(use_libnfc) {
        
        nfc_context *context = NULL;
        
        nfc_init(&context);
        
        if (context) {
            
            nfc_device *device = nfc_open(context, (char *)connstring.c_str());

            if(device) {
                
                if (nfc_initiator_init(device) >= 0) {
                                        
                    nfc_device_set_property_int (device, NP_TIMEOUT_COMMAND, libnfc_timeout);
                    nfc_device_set_property_bool(device, NP_INFINITE_SELECT, false);
                    
                    time_t startTime = time(0);
                    time_t anchorTime = startTime;
                    
                    bool isPolling = true;

                    while (isPolling) {
                        
                        time_t now = time(0);
                        time_t elapsedTime = abs(startTime - now);
                        
                        if(elapsedTime > 0)
                        {
                            startTime = now;
                            PA_YieldAbsolute();
                        }
                        
                        elapsedTime = abs(anchorTime - now);
                        
                        if(elapsedTime < timeout) {
                            
                            nfc_target target;
                            
                            int ret = nfc_initiator_select_passive_target(device, modulation, 0, 0, &target);
                            
                            if(ret > 0) {
                                
                                nfc_target_info nti = target.nti;
                                
                                if(modulation.nmt == NMT_FELICA) {
                                    
                                    nfc_felica_info nfi = nti.nfi;
                                    
                                    std::string _IDm;
                                    print_hex(nfi.abtId, 8, _IDm);
                                    ob_set_s(returnValue, L"IDm", _IDm.c_str());
                                    
                                    std::string _PMm;
                                    print_hex(nfi.abtPad, 8, _PMm);
                                    ob_set_s(returnValue, L"PMm", _PMm.c_str());
                                    
                                    ob_set_b(returnValue, L"success", true);
                                    
                                    isPolling = false;
                                    
                                }

                                if(modulation.nmt == NMT_ISO14443B) {
        
                                    nfc_iso14443b_info nbi = nti.nbi;
                                    
                                    std::string _pupi;
                                    print_hex(nbi.abtPupi, 4, _pupi);
                                    ob_set_s(returnValue, L"pupi", _pupi.c_str());
                                    
                                    std::string _appdata;
                                    print_hex(nbi.abtApplicationData, 4, _appdata);
                                    ob_set_s(returnValue, L"appdata", _appdata.c_str());
                                    
                                    std::string _pinfo;
                                    print_hex(nbi.abtProtocolInfo, 3, _pinfo);
                                    ob_set_s(returnValue, L"pinfo", _pinfo.c_str());
                                    
                                    /*
                                     std::string _cid;
                                     print_hex(&nbi.ui8CardIdentifier, 1, _cid);
                                     ob_set_s(returnValue, L"cid", _cid.c_str());
                                     */
                                    
                                    ob_set_b(returnValue, L"success", true);
                                    
                                    isPolling = false;
                                    
                                }
 
                            }
                            
                        }else{
                            /* timeout */
                            isPolling = false;
                        }

                    }
                     
                }/* nfc_initiator_init */
                nfc_close(device); device = NULL;
            }/* nfc_open */
            nfc_exit(context); context = NULL;
        }/* nfc_init */
 
    }

#endif
    
    PA_ReturnObject(params, returnValue);
}
